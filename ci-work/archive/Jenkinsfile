properties([
    [$class: 'BuildDiscarderProperty', strategy: [$class: 'LogRotator', numToKeepStr: '10']],
    pipelineTriggers([bitbucketPush()]),
    disableConcurrentBuilds()
])

def SLACK_COVERAGE = ''
def SLACK_URL = "<${env.RUN_DISPLAY_URL}|${env.JOB_NAME} #${env.BUILD_NUMBER}>"

def CREDENTIALS_ID_DOCKER_HUB = 'docker-hub-xuver'

node {
    slackSend( color: "#439FE0", message: "${SLACK_URL} Build started :building_construction:" )

    cleanWs()

    checkout scm

    def GIT_COMMIT = sh(script: 'git describe --always', returnStdout: true).trim()
    def BUILD_TIME = sh(script: 'date +%Y%m%d%H%M', returnStdout: true).trim()
    def XUVER_APP_IMAGETAG = "${env.BUILD_NUMBER}-${env.BRANCH_NAME}-${GIT_COMMIT}-${BUILD_TIME}"
    echo "XUVER_APP_IMAGETAG=${XUVER_APP_IMAGETAG}"

    def devImage;
    def devImageArgs = "--mount type=volume,source=xuver_jenkins_app_root_npm,destination=/root/.npm" +
        " --mount type=volume,source=xuver_jenkins_app_node_modules,destination=${WORKSPACE}/node_modules"

    stage('COMPILE WEBPACK') {
        try {
            sh "mkdir -pv ${JENKINS_HOME}/xuver_builds/"
            sh "[ -f ${JENKINS_HOME}/xuver_builds/${env.BRANCH_NAME}.env ] && sed -i \"/^XUVER_APP_IMAGETAG=.*/d\" ${JENKINS_HOME}/xuver_builds/${env.BRANCH_NAME}.env || echo \"env file not found. Continuing...\""
            sh "echo XUVER_APP_IMAGETAG=${XUVER_APP_IMAGETAG} >> ${JENKINS_HOME}/xuver_builds/${env.BRANCH_NAME}.env"
            sh "cat ${JENKINS_HOME}/xuver_builds/${env.BRANCH_NAME}.env"

            writeFile(file: 'xversion.html', text: "xuver app ${XUVER_APP_IMAGETAG}")
            writeFile(file: 'xversion.env', text: "XUVER_APP_IMAGETAG=${XUVER_APP_IMAGETAG}")
            writeFile(file: 'xversion.html', text: "xuver app ${XUVER_APP_IMAGETAG}")
            devImage = docker.build("xuver_jenkins_app", "-f ./ci-work/Dockerfile-compiler ./ci-work")
            devImage.inside(devImageArgs) {
                sh 'cat xversion.html'
                sh 'npm install'
                sh 'npm run build'
                sh 'cd dist && tar -czf ../app-build.tar.gz *'
                archiveArtifacts(
                    artifacts: 'app-build.tar.gz',
                    fingerprint: true
                )
            }
        } catch (exc) {
            slackSend( color: "warning", message: "${SLACK_URL} *Build Failed*" )
            error("Build failed")
        }
    }

     stage('TEST') {
        try {
            devImage.inside(devImageArgs) {
                sh "npm run test -- --coverage --collectCoverageFrom='src/**/*.js' --collectCoverageFrom='!src/root.js' > __tests__log.txt"

                def COVERAGE_PERCENT = sh(
                    returnStdout: true,
                    script: "grep 'All files' __tests__log.txt | sed -e 's/^[^0-9]\\+\\([^ ]\\+\\).\\+/\\1/g'"
                ).trim()
                SLACK_COVERAGE = "Test Coverage <${env.BUILD_URL}CoverageHTMLReport/|${COVERAGE_PERCENT}%>"

                publishHTML([
                    allowMissing: false,
                    alwaysLinkToLastBuild: false,
                    keepAll: true,
                    reportDir: '__tests__coverage/lcov-report',
                    reportFiles: 'index.html',
                    reportName: 'CoverageHTMLReport',
                    reportTitles: 'coverage'
                ])

                 slackSend( color: "good", message: "${SLACK_URL} ${SLACK_COVERAGE}" )
            }
        } catch (exc) {
            slackSend( color: "warning", message: "${SLACK_URL} *Tests Failed*" )
            error("Tests failed")
        }

        def UNNAMED_EXPORTS_SLACK_MESSAGE = ''
        try {
            def UNNAMED_CONNECT_EXPORTS = sh(
                script: "grep -rnE 'export default connect\\(.*\\)' src",
                returnStdout: true
            ).trim()
            if (UNNAMED_CONNECT_EXPORTS) {
                UNNAMED_EXPORTS_SLACK_MESSAGE += 'Found `export default connect()` in:\n' +
                    '```\n' + UNNAMED_CONNECT_EXPORTS + '\n```\n'
            }
        } catch (exc) {}
        try {
            def UNNAMED_WITH_STYLES_EXPORTS = sh(
                script: "grep -rnE 'export default withStyles\\(.*\\)' src",
                returnStdout: true
            ).trim()
            if (UNNAMED_WITH_STYLES_EXPORTS) {
                UNNAMED_EXPORTS_SLACK_MESSAGE += 'Found `export default withStyles()` in:\n' +
                    '```\n' + UNNAMED_WITH_STYLES_EXPORTS + '\n```\n'
            }
        } catch (exc) {}
        if (UNNAMED_EXPORTS_SLACK_MESSAGE) {
            UNNAMED_EXPORTS_SLACK_MESSAGE = 'Found *unnamed exports* :grey_exclamation:\n' +
                UNNAMED_EXPORTS_SLACK_MESSAGE
            slackSend( color: "warning", message: UNNAMED_EXPORTS_SLACK_MESSAGE )
        }
    }

    stage("BUILD Docker Image") {
        try {
            if (env.BRANCH_NAME == 'master') {
                def PROD_IMAGE_ID = "xuver/app:${XUVER_APP_IMAGETAG}"
                def prodImage = docker.build(PROD_IMAGE_ID)

                docker.withRegistry('', "${CREDENTIALS_ID_DOCKER_HUB}") {
                    prodImage.push()
                    prodImage.push('latest')
                }

                slackSend( color: "good", message: "${SLACK_URL} Production image pushed `${PROD_IMAGE_ID}`" )
            } else {
                echo "Only master branch will build and push images"
            }
        } catch (exc) {
            slackSend( color: "warning", message: "${SLACK_URL} *Production image build failed*" )
        }
    }

    stage('Store build info') {
        try {
            def BUILD_INFO_FILE="${JENKINS_HOME}/xuver_builds/${env.BRANCH_NAME}.env"
            echo "Store value XUVER_APP_IMAGETAG=${XUVER_APP_IMAGETAG} in ${BUILD_INFO_FILE}"
            sh "sed -i \"/^XUVER_APP_IMAGETAG=.*/d\" ${BUILD_INFO_FILE}"
            sh "echo XUVER_APP_IMAGETAG=${XUVER_APP_IMAGETAG} >> ${BUILD_INFO_FILE}"
            sh "cat ${BUILD_INFO_FILE}"

            slackSend( color: "good", message: "${SLACK_URL} Build SUCCEED!" )
        } catch (exc) {
            slackSend( color: "warning", message: "${SLACK_URL} *DEV build FAILED*" )
            error("DEV build FAILED")
        }
    }

    if (currentBuild.currentResult == 'SUCCESS') {
        slackSend( color: "good", message: "${SLACK_URL} All Systems Nominal :rocket:" )
    }

    cleanWs()
}
