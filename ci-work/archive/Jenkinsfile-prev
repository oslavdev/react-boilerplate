properties([
    [$class: 'BuildDiscarderProperty', strategy: [$class: 'LogRotator', numToKeepStr: '10']],
    pipelineTriggers([bitbucketPush()]),
    disableConcurrentBuilds()
])

def SLACK_COVERAGE = ''
def SLACK_URL = "<${env.RUN_DISPLAY_URL}|${env.JOB_NAME} #${env.BUILD_NUMBER}>"

def CREDENTIALS_ID_SSH_APP_DEV = 'ssh-key-app-dev'
def CREDENTIALS_ID_DOCKER_HUB = 'docker-hub-xuver'

def PRODUCTION_ADMINS = 'constantin,victor,yaroslav'

node {
    slackSend(
        color: "#439FE0",
        message: "${SLACK_URL} Build started :building_construction:"
    )

    cleanWs()

    checkout scm

    def GIT_COMMIT = sh(script: 'git describe --always', returnStdout: true).trim()

    def devImage;
    def devImageArgs = "--mount type=volume,source=xuver_jenkins_app_root_npm,destination=/root/.npm" +
        " --mount type=volume,source=xuver_jenkins_app_node_modules,destination=${WORKSPACE}/node_modules"

    stage('Build') {
        try {
            devImage = docker.build("xuver_jenkins_app", "./docker")
            devImage.inside(devImageArgs) {
                sh 'npm install'
                sh 'npm run build'
                sh 'cd dist && tar -czf ../app-build.tar.gz *'
                archiveArtifacts(
                    artifacts: 'app-build.tar.gz',
                    fingerprint: true
                )
            }
        } catch (exc) {
            slackSend(
                color: "warning",
                message: "${SLACK_URL} *Build Failed*"
            )
            error("Build failed")
        }
    }


    stage('Test') {
        try {
            devImage.inside(devImageArgs) {
                sh "npm run test -- --coverage --collectCoverageFrom='src/**/*.js' --collectCoverageFrom='!src/root.js' > __tests__log.txt"

                def COVERAGE_PERCENT = sh(
                    returnStdout: true,
                    script: "grep 'All files' __tests__log.txt | sed -e 's/^[^0-9]\\+\\([^ ]\\+\\).\\+/\\1/g'"
                ).trim()
                SLACK_COVERAGE = "Coverage <${env.BUILD_URL}CoverageHTMLReport/|${COVERAGE_PERCENT}%>"

                publishHTML([
                    allowMissing: false,
                    alwaysLinkToLastBuild: false,
                    keepAll: true,
                    reportDir: '__tests__coverage/lcov-report',
                    reportFiles: 'index.html',
                    reportName: 'CoverageHTMLReport',
                    reportTitles: 'coverage'
                ])
            }
        } catch (exc) {
            slackSend(
                color: "warning",
                message: "${SLACK_URL} :broken_heart: *Tests Failed*"
            )
            error("Tests failed")
        }

        def UNNAMED_EXPORTS_SLACK_MESSAGE = ''
        try {
            def UNNAMED_CONNECT_EXPORTS = sh(
                script: "grep -Rl 'export default connect(' src",
                returnStdout: true
            ).trim()
            if (UNNAMED_CONNECT_EXPORTS) {
                UNNAMED_EXPORTS_SLACK_MESSAGE += 'Found `export default connect()` in:\n' +
                    '```\n' + UNNAMED_CONNECT_EXPORTS + '\n```\n'
            }
        } catch (exc) {}
        try {
            def UNNAMED_WITH_STYLES_EXPORTS = sh(
                script: "grep -Rl 'export default withStyles(' src",
                returnStdout: true
            ).trim()
            if (UNNAMED_WITH_STYLES_EXPORTS) {
                UNNAMED_EXPORTS_SLACK_MESSAGE += 'Found `export default withStyles()` in:\n' +
                    '```\n' + UNNAMED_WITH_STYLES_EXPORTS + '\n```\n'
            }
        } catch (exc) {}
        if (UNNAMED_EXPORTS_SLACK_MESSAGE) {
            UNNAMED_EXPORTS_SLACK_MESSAGE = 'Found *unnamed exports* :grey_exclamation:\n' +
                UNNAMED_EXPORTS_SLACK_MESSAGE
            slackSend(
                color: "warning",
                message: UNNAMED_EXPORTS_SLACK_MESSAGE
            )
        }
    }



stage('Dev Deploy') {
        try {
            if (env.BRANCH_NAME == 'master-fake-branch') {
                withCredentials(
                    bindings: [sshUserPrivateKey(credentialsId: "${CREDENTIALS_ID_SSH_APP_DEV}", keyFileVariable: 'SSH_KEY')]
                ) {
                    withEnv(["SSH_HOST=app.dev.xuver.com", "SSH_PORT=2002", "SSH_USER=www", "SSH_DIR=/var/www"]) {
                        sh '''
                            ssh \
                            -o StrictHostKeyChecking=no \
                            -i ${SSH_KEY} \
                            -p ${SSH_PORT} \
                            ${SSH_USER}@${SSH_HOST} \
                            rm -rf ${SSH_DIR}/*
                        '''
                        sh '''
                            scp \
                            -o StrictHostKeyChecking=no \
                            -i ${SSH_KEY} \
                            -P ${SSH_PORT} \
                            -r \
                            dist/* ${SSH_USER}@${SSH_HOST}:${SSH_DIR}/
                        '''
                    }
                }
            } else {
                echo "Only master branch is deployed"
            }
        } catch (exc) {
            slackSend(
                color: "warning",
                message: "${SLACK_URL} *Dev Deploy Failed*"
            )
            error("Dev Deploy failed")
        }
    }

    if (currentBuild.currentResult == 'SUCCESS') {
        slackSend(
            color: "good",
            message: "${SLACK_URL} All Systems Nominal :rocket: ${SLACK_COVERAGE}"
        )
    }

    stage("Prod Image") {
        try {
            if (env.BRANCH_NAME == 'master') {
                def DO_BUILD = false

                def TIMEOUT_IN_SECONDS = 60
                long startTime = System.currentTimeMillis()
                try {
                    timeout(time: TIMEOUT_IN_SECONDS, unit: 'SECONDS') {
                        input(
                            message: "Build and push production image?",
                            ok: "Yes",
                            submitter: "${PRODUCTION_ADMINS}"
                        )
                        DO_BUILD = true
                    }
                } catch (err) {
                    long timePassed = System.currentTimeMillis() - startTime
                    if (timePassed >= TIMEOUT_IN_SECONDS * 1000) {
                        echo 'Timed out'
                    } else {
                        throw err
                    }
                }

                if (DO_BUILD) {
                    slackSend(
                        color: "#439FE0",
                        message: "${SLACK_URL} Production image build started"
                    )

                    def PROD_IMAGE_ID = "xuver/app:${GIT_COMMIT}"
                    def prodImage = docker.build(PROD_IMAGE_ID)

                    docker.withRegistry('', "${CREDENTIALS_ID_DOCKER_HUB}") {
                        prodImage.push()
                        prodImage.push('latest')
                    }

                    slackSend(
                        color: "good",
                        message: "${SLACK_URL} Production image pushed `${PROD_IMAGE_ID}`"
                    )
                }
            } else {
                echo "Only master branch is used for production"
            }
        } catch (exc) {
            slackSend(
                color: "warning",
                message: "${SLACK_URL} *Production image build failed*"
            )
        }
    }

    cleanWs()
}
