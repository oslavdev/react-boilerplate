properties([
    [$class: 'BuildDiscarderProperty', strategy: [$class: 'LogRotator', numToKeepStr: '10']],
    pipelineTriggers([bitbucketPush()]),
    disableConcurrentBuilds()
])

def SLACK_COVERAGE = ''
def SLACK_URL = "<${env.RUN_DISPLAY_URL}|${env.JOB_NAME} #${env.BUILD_NUMBER}>"

def CREDENTIALS_ID_DOCKER_HUB = 'docker-hub-xuver'

node {
    slackSend( color: "#439FE0", message: "${SLACK_URL} Build started :building_construction:" )

    cleanWs()

    checkout scm

    def GIT_COMMIT = sh(script: 'git describe --always', returnStdout: true).trim()
    def BUILD_TIME = sh(script: 'date +%Y%m%d%H%M', returnStdout: true).trim()
    def XUVER_APP_IMAGETAG = "${env.BUILD_NUMBER}-${env.BRANCH_NAME}-${GIT_COMMIT}-${BUILD_TIME}"
    echo "XUVER_APP_IMAGETAG=${XUVER_APP_IMAGETAG}"

    def devImage;
    def devImageArgs = "--mount type=volume,source=xuver_jenkins_app_root_npm,destination=/root/.npm" +
        " --mount type=volume,source=xuver_jenkins_app_node_modules,destination=${WORKSPACE}/node_modules"

    stage('COMPILE') {
        try {
            writeFile(file: 'xversion.html', text: "xuver app ${XUVER_APP_IMAGETAG}")
            devImage = docker.build("xuver_jenkins_app", "./docker")
            devImage.inside(devImageArgs) {
                sh 'cat xversion.html'
                sh 'npm install'
                sh 'npm run build'
                sh 'cd dist && tar -czf ../app-build.tar.gz *'
                archiveArtifacts(
                    artifacts: 'app-build.tar.gz',
                    fingerprint: true
                )
            }
        } catch (exc) {
            slackSend( color: "warning", message: "${SLACK_URL} *Build Failed*" )
            error("Build failed")
        }
    }


    stage('TEST') {
        try {
            devImage.inside(devImageArgs) {
                sh "npm run test -- --coverage --collectCoverageFrom='src/**/*.js' --collectCoverageFrom='!src/root.js' > __tests__log.txt"

                def COVERAGE_PERCENT = sh(
                    returnStdout: true,
                    script: "grep 'All files' __tests__log.txt | sed -e 's/^[^0-9]\\+\\([^ ]\\+\\).\\+/\\1/g'"
                ).trim()
                SLACK_COVERAGE = "Coverage <${env.BUILD_URL}CoverageHTMLReport/|${COVERAGE_PERCENT}%>"

                publishHTML([
                    allowMissing: false,
                    alwaysLinkToLastBuild: false,
                    keepAll: true,
                    reportDir: '__tests__coverage/lcov-report',
                    reportFiles: 'index.html',
                    reportName: 'CoverageHTMLReport',
                    reportTitles: 'coverage'
                ])
            }
        } catch (exc) {
            slackSend( color: "warning", message: "${SLACK_URL} *Tests Failed*" )
            error("Tests failed")
        }

        def UNNAMED_EXPORTS_SLACK_MESSAGE = ''
        try {
            def UNNAMED_CONNECT_EXPORTS = sh(
                script: "grep -Rl 'export default connect(' src",
                returnStdout: true
            ).trim()
            if (UNNAMED_CONNECT_EXPORTS) {
                UNNAMED_EXPORTS_SLACK_MESSAGE += 'Found `export default connect()` in:\n' +
                    '```\n' + UNNAMED_CONNECT_EXPORTS + '\n```\n'
            }
        } catch (exc) {}
        try {
            def UNNAMED_WITH_STYLES_EXPORTS = sh(
                script: "grep -Rl 'export default withStyles(' src",
                returnStdout: true
            ).trim()
            if (UNNAMED_WITH_STYLES_EXPORTS) {
                UNNAMED_EXPORTS_SLACK_MESSAGE += 'Found `export default withStyles()` in:\n' +
                    '```\n' + UNNAMED_WITH_STYLES_EXPORTS + '\n```\n'
            }
        } catch (exc) {}
        if (UNNAMED_EXPORTS_SLACK_MESSAGE) {
            UNNAMED_EXPORTS_SLACK_MESSAGE = 'Found *unnamed exports* :grey_exclamation:\n' +
                UNNAMED_EXPORTS_SLACK_MESSAGE
            slackSend( color: "warning", message: UNNAMED_EXPORTS_SLACK_MESSAGE )
        }
    }

    stage("BUILD Docker Image") {
        try {
            if (env.BRANCH_NAME == 'master') {
                def PROD_IMAGE_ID = "xuver/app:${XUVER_APP_IMAGETAG}"
                def prodImage = docker.build(PROD_IMAGE_ID)

                docker.withRegistry('', "${CREDENTIALS_ID_DOCKER_HUB}") {
                    prodImage.push()
                    prodImage.push('latest')
                }

                slackSend( color: "good", message: "${SLACK_URL} Production image pushed `${PROD_IMAGE_ID}`" )
            } else {
                echo "Only master branch will build and push images"
            }
        } catch (exc) {
            slackSend( color: "warning", message: "${SLACK_URL} *Production image build failed*" )
        }
    }

    stage('DEPLOY to DEV.xuver.com') {
        try {
            if (env.BRANCH_NAME == 'master') {
                echo "XUVER_APP_IMAGETAG=${XUVER_APP_IMAGETAG}"
                def HOST_IP = sh(script: "ip route | grep \"default via\" | cut -d\" \" -f3", returnStdout: true).trim()

                sh "echo \"XUVER_APP_IMAGETAG=${XUVER_APP_IMAGETAG}\""
                sh "ssh xu@${HOST_IP} sed -i \"/^XUVER_APP_IMAGETAG=.*/d\" /xuver/hostspecific"
                sh "ssh xu@${HOST_IP} \"echo XUVER_APP_IMAGETAG=${XUVER_APP_IMAGETAG} >> /xuver/hostspecific\""
                sh "ssh xu@${HOST_IP} cat /xuver/hostspecific"
                sh "ssh xu@${HOST_IP} bash /home/xu/configs/xuver.deployment/deploydown.sh -r -v"
                sh "ssh xu@${HOST_IP} bash /home/xu/configs/xuver.deployment/deployup.sh -s"

                slackSend( color: "good", message: "${SLACK_URL} DEV deploy SUCCEED!" )
            } else {
                echo "Only master branch is deployed"
            }
        } catch (exc) {
            slackSend( color: "warning", message: "${SLACK_URL} *DEV deploy FAILED*" )
            error("DEV deploy FAILED")
        }
    }

    if (currentBuild.currentResult == 'SUCCESS') {
        slackSend( color: "good", message: "${SLACK_URL} All Systems Nominal :rocket:" )
    }

    cleanWs()
}
